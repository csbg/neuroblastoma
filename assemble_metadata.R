# Combine metadata generated by several scripts into a single data frame.
#
# Creates the following files:
# * metadata.csv - combined metadata exported via `write_csv()`
# * metadata.rds - combined metadata stored with factor levels
# * celltype_details.rds - processed SingleR details

library(tidyverse)
library(fs)
source("common_functions.R")



# Functions ---------------------------------------------------------------

#' Load cell type data from SingleR.
#'
#' @param file SingleR results file (`cell_types_singler_[ref]_[labels].csv`).
#'
#' @return A dataframe with one row per cell and 12 columns:
#'   * `cell`: barcode
#'   * `first_labels`,
#'     `tuning_scores_first`,
#'     `tuning_scores_second`, and
#'     `labels`: reused from the output of `SingleR::SingleR()`
#'   * `median_score`: median of cell type-specific correlation scores
#'   * `diff_next`: difference between the best score and next best score
#'   * `label_score`: score for the assigned label
#'   * `delta_score`: difference between `label_score` and `median_score`
#'   * `median_delta_score`: median of `delta_score` across all cells
#'                           of the assigned type
#'   * `mad_delta_score`: mean absolute deviation
#'   * `z_score`: `delta_score` normalized via median and MAD
load_singler_data <- function(file) {
  info("Loading {file}")
  df <- 
    read_csv(file) %>%
    rowwise() %>% 
    mutate(median_score = median(c_across(starts_with("score_")))) %>% 
    ungroup() %>% 
    mutate(diff_next = tuning_scores_first - tuning_scores_second) %>%
    pivot_longer(
      starts_with("score_"),
      names_to = "scores",
      names_prefix = "score_",
      values_to = "label_score"
    ) %>%
    filter(scores == labels) %>%
    mutate(delta_score = label_score - median_score) %>%
    select(!c(pruned_labels, scores))
  
  left_join(
    df,
    df %>%
      group_by(labels) %>%
      summarise(
        median_delta_score = median(delta_score),
        mad_delta_score = mad(delta_score)
      ),
    by = "labels"
  ) %>%
    mutate(z_score = (delta_score - median_delta_score) / mad_delta_score)
}



#' Load cell metadata from several CSV files.
#' 
#' @param folder Folder containing CSV files.
#'
#' @return A dataframe with metadata combined from several files.
load_cell_metadata <- function(folder) {
  files <- c(
    "metadata_seurat.csv",
    "metadata_monocle.csv",
    "doublet_scores.csv"
  )
  
  nb_groups <-
    read_csv("metadata/sample_groups.csv", comment = "#") %>%
    distinct(sample, group) %>% 
    mutate(group = as_factor(group) %>% fct_relevel("I", "II", "III", "IV")) %>%
    arrange(group, sample) %>%
    mutate(sample = as_factor(sample), sample_id = as.integer(sample))
  
  str_glue("{folder}/{files}") %>% 
    map(read_csv) %>% 
    reduce(left_join, by = "cell", suffix = c("_seurat", "_monocle")) %>%
    left_join(nb_groups, by = "sample") %>%
    mutate(
      sample = as_factor(sample) %>% fct_reorder(sample_id),
      across(matches("cluster|partition"), ~as_factor(.x) %>% fct_inseq())
    ) %>%
    select(!sample_id)
}



#' Combine general metadata and cell types.
#'
#' @param df_metadata Dataframe returned by `load_cell_metadata()`.
#' @param singler_list Named list of dataframes as returned by
#'   `load_singler_data()`.
#' @param min_z_score Minimum z score, ...
#' @param min_delta_score minimum delta score, ...
#' @param min_diff_next ... and minimum `diff_next` for a cell type label to be
#'   retained. Other labels are set to `NA`. This filtering essentially
#'   reproduces the functionality of `SingleR::pruneScores()`.
#'
#' @return The dataframe provided by `df_metadata`, with two additional columns
#'   `cell_type_fine` and `cell_type_broad`.
add_cell_types <- function(df_metadata,
                           singler_list,
                           min_z_score = -3,
                           min_delta_score = -Inf,
                           min_diff_next = 0) {
  df_cell_types <- 
    imap(
      singler_list,
      function(df, file) {
        ref <- str_match(file, "cell_types_singler_(.*)_")[, 2]
        label <- ifelse(str_detect(file, "main"), "broad", "fine")
        type_name <- str_glue("cell_type_{ref}_{label}")
        
        df %>% 
          transmute(
            cell = cell,
            {{type_name}} :=
              case_when(
                z_score >= min_z_score &
                  delta_score >= min_delta_score &
                  diff_next > min_diff_next
                ~ labels,
                TRUE
                ~ NA_character_
              ) %>% 
              as_factor() %>% 
              fct_infreq()
          )
      }
    ) %>% 
    reduce(left_join, by = "cell")

  left_join(df_metadata, df_cell_types, by = "cell")
}

#' #' Add clusters obtained by subclustering.
#' #'
#' #' @param df_seurat Dataframe returned by `load_seurat_data()`
#' #' @param folder Dataset folder
#' #'
#' #' @return `df_seurat` with an additional column `refined_cluster`.
#' add_refined_clusters <- function(df_seurat, folder) {
#'   refined_cluster_file <- str_glue("{folder}/manual/subcluster_mapping.csv")
#'   
#'   df_seurat %>% 
#'     mutate(
#'       supercluster = as.character(integrated_snn_res.0.5),
#'       subcluster = as.character(subcluster_mid_0.2)
#'     ) %>% 
#'     left_join(
#'       read_csv(refined_cluster_file, col_types = "ccc"),
#'       by = c("supercluster", "subcluster")
#'     ) %>% 
#'     select(!c(supercluster, subcluster)) %>% 
#'     mutate(
#'       refined_cluster =
#'         refined_cluster %>% 
#'         coalesce(integrated_snn_res.0.5) %>% 
#'         as_factor() %>% 
#'         fct_relevel(function(l) str_sort(l, numeric = TRUE))
#'     )
#' }
#' 
#' #' Add clusters obtained by discarding rare cell types within each original
#' #' cluster and splitting them by more common cell types.
#' #'
#' #' @param df_seurat Dataframe returned by `load_seurat_data()`
#' #' @param folder Dataset folder
#' #'
#' #' @return `df_seurat` with an additional column `split_cluster`.
#' add_split_clusters <- function(df_seurat, folder) {
#'   split_cluster_file <- str_glue("{folder}/manual/splitcluster_mapping.csv")
#'   df_seurat %>% 
#'     mutate(tmp_col = as.character(cell_type_broad_lumped)) %>% 
#'     left_join(
#'       read_csv(split_cluster_file, col_types = "ccc"),
#'       by = c("integrated_snn_res.0.5", tmp_col = "cell_type_broad_lumped")
#'     ) %>% 
#'     mutate(
#'       split_cluster =
#'         split_cluster %>%
#'         as_factor() %>% 
#'         fct_relevel(function(l) str_sort(l, numeric = TRUE))
#'     ) %>% 
#'     select(!tmp_col)
#' }



# Load data ---------------------------------------------------------------

folder <- "data_generated"

singler_data <- map(
  dir_ls(folder, regex = "cell_types"),
  load_singler_data
)

nb_data <-
  load_cell_metadata(folder) %>% 
  add_cell_types(singler_data) %>%
  # add_refined_clusters(folder) %>% 
  # add_split_clusters(folder) %>% 
  {.}



# Export data -------------------------------------------------------------

nb_data %>% write_csv(str_glue("{folder}/metadata.csv"))
nb_data %>% saveRDS(str_glue("{folder}/metadata.rds"))
singler_data %>% saveRDS(str_glue("{folder}/celltype_details.rds"))
